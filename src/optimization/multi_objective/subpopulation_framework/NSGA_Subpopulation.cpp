

#include"Novelty_Subpopulation.h"


Novelty_Subpopulation::Novelty_Subpopulation(int subpopulation_size, int number_of_problems, int problem_size)
{
	this->problem_size= problem_size;
	this->subpopulation_size= subpopulation_size;

	archive_size_limit=700;
	available_index=0;
	individual_size=number_of_problems + problem_size;
	this->number_of_problems= number_of_problems;

	subpopulation= (double**)malloc(sizeof(double*)*subpopulation_size);
	for(int i=0;i<subpopulation_size; ++i)
	{	
		subpopulation[i]= (double*)malloc(sizeof(double)*(individual_size));		
	}

	k=10;

	printf("pareto\n");
}
	
//Is individual a weaker than individual b?
bool Novelty_Subpopulation::weaker(double* a, double* b)
{
	int i;

	for(i=0; i<number_of_problems; ++i)
	{
		if(a[problem_size + i] <  b[problem_size + i])
		{
			return true;
		}
	}

	return false;
}

//Is individual a non dominated by individual b?
bool Novelty_Subpopulation::isNondominated(double* a, double* b)
{
	int i;

	for(i=0; i<number_of_problems; ++i)
	{
		//if some a's solution is greater than b's, it is non dominated
		if(a[problem_size + i] >  b[problem_size + i])
		{
			return true;
		}
	}

	return false;
}

void Novelty_Subpopulation::preProcess()
{
	
	//check if it is the first time the preProcess() is run
	if(front1.empty())
	{
		//Going to create the 3 Frontal Pareto layers

		//printf("%d\n",front1.size());
		printf("size %d  remain %zd fronts %zd %zd %zd %zd all fronts %zd \n",subpopulation_size, novelty_sorted.size(),front1.size(),front2.size(),front3.size(),free_arrays.size(),all_fronts.size());

		//Create the Sorted Fronts Vector (This time not really sorted!)

		double* new_array;
		int size= sizeof(double)*(individual_size);		

		for(int i=0;i<subpopulation_size; ++i)
		{	
			new_array= (double*)malloc(size);		

			memcpy(new_array,subpopulation[i],size);
		
			novelty_sorted.push_back(new_array);
		}
		

		createFronts();
		

		printf("size %d  remain %zd fronts %zd %zd %zd %zd all fronts %zd \n",subpopulation_size, novelty_sorted.size(),front1.size(),front2.size(),front3.size(),free_arrays.size(),all_fronts.size());

	}
	//no the first time to run the preProcess()
	else
	{
		//printf("Nondominated\n");

		//Copy all fronts to the all_fronts vector

		joinNondominated();
		

		//printArray(new_novelty_array, size);	
		//createNoveltyBasedSubpopulation();
		createCrowdingdistanceBasedSubpopulation();
			
		//Create the Pareto Fronts, which will be used to determine if a new solution generated by operators
		//will be added to the archive or not.
		createFronts();

		all_fronts.clear();

	}

}

//based on the List of novelty_sorted it will create the separated Fronts
void Novelty_Subpopulation::createFronts()
{
	createFront(front1);
	
	createFront(front2);

	createFront(front3);
	
//	createFront(front4);
	
//	createFront(front5);

	//move the remained arrays to the free arrays list. Which will be reused, to avoid unnecessary allocation
	free_arrays.splice(free_arrays.begin(), novelty_sorted);
}

//some non dominated vectors are already present in the all_fronts vector, so
//this function will add the fronts from the last iteraction there
void Novelty_Subpopulation::joinNondominated()
{
	//copy fronts to the same vector
	
	copyFront(front1);
	
	copyFront(front2);
	
	copyFront(front3);
	
}
	
void Novelty_Subpopulation::copyFront(vector<double*>& front)
{
	for(;!front.empty();)
	{
		all_fronts.push_back(front.back());
		front.pop_back();
	}

}
	
void Novelty_Subpopulation::createFront(vector<double*>& front)
{
	uint i;

	//Creating the First Front

	list<double*>::iterator it;
	for(it = novelty_sorted.begin(); it!= novelty_sorted.end() ; )
	{
		double* this_array= *it;

		bool non_dominated= true;
		
		for(i = 0; i < front.size() && non_dominated==true ; ++i)
		{
			//double* other_array= *other;
		
			non_dominated= isNondominated(this_array,front[i]);
		}

		list<double*>::iterator other;
		for(other = novelty_sorted.begin(); other!= novelty_sorted.end() && non_dominated==true; ++other)
		{
			//other must be different from it
			if(other!=it)
			{
				double* other_array= *other;
			
				non_dominated= isNondominated(this_array,other_array);
			}
		}

		//if non dominated insert it on the front and remove from the list
		if(non_dominated==true)
		{
			//firstly, store it on the front
			front.push_back(*it);

			//erase it and go to the next individual
			list<double*>::iterator tmp_it;
			tmp_it = it;
			++it;
			novelty_sorted.erase(tmp_it);
				
		}
		else
		{
			++it;
		}

	}
}

void Novelty_Subpopulation::createNoveltyBasedSubpopulation()
{
	//Calculating the Novelty (novelty in the fitness space)

	int size= all_fronts.size();
	novelty_array= (double*)malloc(sizeof(double)*size);	
	double* new_novelty_array= (double*)malloc(sizeof(double)*size);	
	double* nearest_neighbors_distance= (double*)malloc(sizeof(double)*size);	
	int* index_array= (int*)malloc(sizeof(int)*size);		
	int i,j,m;

	for(i=0;i<size;++i)
	{
		
		//the index_array will be used later on, 
		//but it needs to be assigned to the numbers of all indexes in the all_fronts vector
		index_array[i]=i;

		//calculating all distances
		for(j=0;j<size;++j)
		{
			nearest_neighbors_distance[j]= 0;
			if(j!=i)
			{
				double sum=0;
				for(m=0; m<number_of_problems; ++m)
				{
					sum+=   (all_fronts[i][problem_size + m]- all_fronts[j][problem_size + m])*
						(all_fronts[i][problem_size + m]- all_fronts[j][problem_size + m]);
				}
				nearest_neighbors_distance[j]= sqrt(sum);
			}
		}
		
		//sorting nearest neighbors
		qsort(nearest_neighbors_distance, size, sizeof(double), double_comparison);

		//calculating the average distance between the k nearest 
		//(it is used from 1 to k+1, because the first neighbor is itself)
		double sum=0;
		for(j=1; j<k+1; ++j)
		{
			sum+= nearest_neighbors_distance[j];
		}
		novelty_array[i]= sum/k;
	}


	//Sorting by novelty
		
	qsort(index_array,size,sizeof(int),novelty_comparison);
	
	//Copying the sorted array to the novelty_sorted 
	//And populating the subpopulation with the highest novelty individuals
	for(i=0;i<size && i<archive_size_limit;++i)
	{
		int index= index_array[i];

		new_novelty_array[i]=novelty_array[index];
		novelty_sorted.push_back(all_fronts[index]);

		if(i<subpopulation_size)
		{
			memcpy(subpopulation[i],all_fronts[index],sizeof(double)*individual_size);
		}

	}

}

void Novelty_Subpopulation::createCrowdingdistanceBasedSubpopulation()
{
	
	//Calculating the Novelty (novelty in the fitness space)

	int size= all_fronts.size();
	novelty_array= (double*)malloc(sizeof(double)*size);	
	double* new_novelty_array= (double*)malloc(sizeof(double)*size);	
	paar* single_objective= (paar*)malloc(sizeof(paar)*size);	
	int* index_array= (int*)malloc(sizeof(int)*size);		
	int i,j;
	
	for(i=0;i<size;++i)
	{
		novelty_array[i]=0;
		single_objective[i].index= i;
		
		//the index_array will be used later on, 
		//but it needs to be assigned to the numbers of all indexes in the all_fronts vector
		index_array[i]=i;
	}

	//for all objectives
	for(i=0;i<number_of_problems;++i)
	{

		//set the single_objective values
		for(j=0;j<size;++j)
		{
			single_objective[j].value=all_fronts[j][problem_size+i];
		}
		
		//sort by the value of the objective
		qsort(single_objective, size, sizeof(paar), paar_comparison);

//		for(j=0;j<size;++j)
//		{
//			printf("index %d value %.2f\n",single_objective[j].index,single_objective[j].value);
//		}

		//first and last individual in this single objective, receive maximum distance (they are sure to be selected)
		int index= single_objective[0].index;
		novelty_array[index]= 10000;
		index= single_objective[size-1].index;
		novelty_array[index]= 10000;

		for(j=1;j<size-1;++j)
		{
			int index= single_objective[j].index;
			novelty_array[index]= novelty_array[index] + (single_objective[j+1].value-single_objective[j-1].value);
		}


	}
		
	/*
        :wq
		//calculating all distances
		for(j=0;j<size;++j)
		{
			nearest_neighbors_distance[j]= 0;
			if(j!=i)
			{
				double sum=0;
				for(m=0; m<number_of_problems; ++m)
				{
					sum+=   (all_fronts[i][problem_size + m]- all_fronts[j][problem_size + m])*
						(all_fronts[i][problem_size + m]- all_fronts[j][problem_size + m]);
				}
				nearest_neighbors_distance[j]= sqrt(sum);
			}
		}
		
		//sorting nearest neighbors
		qsort(nearest_neighbors_distance, size, sizeof(double), double_comparison);

		//calculating the average distance between the k nearest 
		//(it is used from 1 to k+1, because the first neighbor is itself)
		double sum=0;
		for(j=1; j<k+1; ++j)
		{
			sum+= nearest_neighbors_distance[j];
		}
		novelty_array[i]= sum/k;
	}
*/

	//Sorting by Crowding Distance
	
	qsort(index_array,size,sizeof(int),novelty_comparison);

	//Copying the sorted array to the novelty_sorted 
	//And populating the subpopulation with the highest novelty individuals
	for(i=0;i<size && i<archive_size_limit;++i)
	{
		int index= index_array[i];

		new_novelty_array[i]=novelty_array[index];
		novelty_sorted.push_back(all_fronts[index]);

		if(i<subpopulation_size)
		{
			memcpy(subpopulation[i],all_fronts[index],sizeof(double)*individual_size);
		}

	}


}

void Novelty_Subpopulation::addIndividual(double* ind)
{
	unsigned int i;

	vector<double*> last_front= front3;

	bool non_dominated= true;
	
	for(i = 0; i < last_front.size() && non_dominated==true ; ++i)
	{
		//double* other_array= *other;
	
		non_dominated= isNondominated(ind,last_front[i]);
	}
	
	if(non_dominated==true)
	{
		double* new_individual;

		//allocate array space or find it on the list of available arrays
		if(!free_arrays.empty())
		{
			new_individual= free_arrays.front();
			free_arrays.pop_front();
			
			memcpy(new_individual, ind, sizeof(double)*individual_size);
		}
		//list empty, allocate space
		else
		{
			new_individual= (double*)malloc(sizeof(double)*individual_size);
			
			memcpy(new_individual, ind, sizeof(double)*individual_size);
		}

		all_fronts.push_back(new_individual);
		
		//printf("Non dominated\n");
		//printArray(all_fronts[all_fronts.size()-1],individual_size);
		//printArray(new_individual,individual_size);
	}

}

void Novelty_Subpopulation::storeSubpopulation(const char* filename)
{
	writeCSV(filename, subpopulation,available_index, individual_size,"a");
	writeCSV(filename, front1.data(), front1.size(), individual_size,"a");
}
